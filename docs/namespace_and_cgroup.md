本文档描述了我在zcore的基础上实现namespace（主要是这些）和cgroup的部分的工作

（请不要计较本文档的排版，用vim写md让我非常难受）

哎呀，总之无论如何，先感谢杨德睿大佬！

目标

    7种namespace的实现，以及进程对相应数据结构的访问的函数等等。

    Mount Namespace

    UTS Namespace（done）

    IPC Namespace

    PID Namespace

    Network Namespace

    User Namespace

    Cgroup Namespace

    代码的主要实现在linux-object::namespace，但是因为他涉及到诸多syscall，以及需要改写process等一些数据结构，所以在linux-syscall这些地方里面同样有大量的改动。

1/设计内容及开发log

内核数据结构
    
    管理所有namespace的数据结构

    对于单个namespace的数据结构，由于总共有7种namespace，因此数据结构也有不同，他们会放进task中，当然由于这里面task对zircon的继承，所以在zircon-object里面也会有所改动

    在整个内核的初始化阶段，对内核相应数据结构进行创建，以及最初的namespace的创建（比如1号进程会归属于默认的namespace）

    （2022.08.22更改设计）

    内核没有一个用于统一管理所有namespace的实例了，因为我发现没必要，而且，本身namespace的构建应当是一棵树，就是新建namespace会成为上层的子节点，所以，整个数据结构应该改为，最初的那个init的namespace是整个namespace树的根，而且只初始化这个实例，而其他的则像一颗树一样进行操作。

    后来看到setns函数，认为还是有必要实现一个hash，某个hash值指向一个namespace。

    （2022.08.22增加设计）

    Linux namespace应当被视为一个文件描述符，好吧，我去看文件系统的实现吧，inode应该是一个泛型的实现，这里可以进行扩展。

    但是这样有个问题，linux有万物皆文件的思想，但是zcore不是，他没有把进程视作一种文件，所以‘/proc’你是看不到的，因为压根没有，那么本来应该挂在/proc/pid/ns这里的namespace，更加没法实现。

    原本，我认为可以通过建立一个ns文件夹把这些给放进去，但是随之而来的诸多问题让我选择放弃。

    然而file里面仍然要求给定路径。

    （2022.08.25）放弃上面那个想法吧，改成文件太麻烦了。

    （2022.08.26） 继续增加改动，使用KoID唯一标识某个ns（这是为了适应这个内核而做的改动），并且和最初想法一样，使用一个统一的全局管理实例，来进行管理，在这同时使用树的方式进行管理（因为他们天然具有树的结构），另外，在Linux中，每个进程都有统一的

    由于这些namespace很多都有复制原来的，定一个copy的trait吧。

    下面会分别对这些namespace进行分析记录。

    还有就是对clone函数的改进，namespace应当被视作每个进程的属性之一，因此clone创建的时候，会有相应的flag描述对应的namespace，好在flag的工作已经被完成了。

    具体请见linux-syscall/src/task.rs里面CloneFlags的描述。因此，对于相应的flag，需要创建对应的namespace（可能需要阅读linux源码）

    其他：我真的很想弄那个cfg来进行条件编译，但是，我按照说明去toml文件里面加了，以及在makefile 里面加了东西，但是，并没有成功。唯一成功的办法是，关掉--no-default-feature选项，我也很想知道我该怎么做。

    当然即便如此，我也不是那种乱放代码的人，我会在我增加的代码部分，增加 #[cfg(feature = "namespace")]的注释，有懂的人帮忙全局搜索一下代码，改成条件编译吧

    （2022.08.24）听从杨德瑞大佬的建议，大概是使用了什么什么cfg的模块然后嵌套在里面所以如果外面的那个cfg不给过，然后里面的也就没了，我的意见是，不管这玩意了，先把功能跑通再说吧。

2/初始化

    由于条件编译，需要在toml文件和zcore的makefile更改条件（搞不定，不搞了，到时候问别人吧）

    初始化一个init的namespace，另外如上面所述，弄一个hash用于id和namespace的对应用于查找。（由于setns函数的语义，显然是全局可见所有内容的）

3/clone函数改写

    clone函数中定义了namespace的几个namespace的结构。而原本的clone函数只是简单粗暴的忽略了这几个flag。

    显然，这几种ns的组合非常多，需要各自判断if

    另外，fork肯定没法改了，所以fork之后会返回那个pid，根据pid去加东西就好了。

4/类的继承

    上面这些不同的namespace应当具有一个公共的父类，用于ns树的建立，hash的索引等等。因此需要在这里实现一个继承

5/Mount Namespace

    mount主要是文件系统，一个比较麻烦的点在于，他用的fs是rcore的那个fs，而且是使用调包的方式，这就不太好改了。

    mount使用的flag是Cloneflags::NEWNS（据说不用newmount的原因是因为当初Linux设计的时候，没考虑还会有其他的namespace，哈哈哈哈）

    chroot操作：因为一开始mount namespace是将原先的那个文件系统全都拷贝一遍的，与其他的namespace不同的是，需要添加一个chroot操作，让他的根目录发生变化。

    关于拷贝整颗inode树的做法。这在linux中有一个copy_tree函数来实现。非常可惜的是，这并没有可用的实现给我参考。

6/Pid Namespace

    Pid命名空间和上面有所不同，父空间中能看到子空间的进程，而且他们在不同的空间中存在不同的pid编号。在zcore中原有的设计中已经存在了一个KoID，我认为这无需修改（只不过一些指向这个KoID的操作也许会发生变化）。不同的是，一个进程需要维护在父命名空间和子命名空间（如果有祖父，那也要继续嵌套下去）中的pid映射。

    所以在Pid Namespace中不能那么简单的就干下去了。但是如果像Linux那样直接指针指来指去，也很讨厌。rust不能这么干

    （2022.08.25）继续更改设计，KoID用于全局标识一个进程的唯一符号——这也没法改呀，他child的列表就是KoID到子进程的hash，改一改，牵一发动全身。所以这样，在Pid Namespace中维护每个进程在该namespace中的一个KoID到namespace下的pid的映射。创建的时候需要向上递归的在ns中增加

    （2022.08.29）时间过的真快，我要加快进度了。tgid,pgid什么的要不要实现的问题，因为本身这些进程组，线程组啊什么的，跟我做的事情关系不大吧。

    （2022.09.06）需要更改的系统调用，主要考虑到已经实现了的需要更改的，有sys_getpid，sys_gettid，sys_getppid，sys_set_tid_address。需要注意这个getppid，就是得到父进程的pid，如果当前进程是某个pidns的根进程，那么不应该看见其父进程的pid，换句话说，在当前pidns下，在他看来，他就是根进程。
    
    除此之外，在创建新的进程和新的线程的时候，需要插入数据结构。包括初始化的时候，fork from和vfork以及clone函数中创建新的线程和进程的部分。

    尤其需要注意的是在clone，当创建了一个新的ns之后，这时候肯定会创建新的proc，需要把这个新的proc的对应pid插入到新的ns中，并分配新的pid（当然，线程也要）

    其实主要包括tid和pid两个部分，现行的办法是统一使用KoID。

    测试：由于一直说的那样，木有/proc，确实不容易测试，但是由于其目的在于控制进程看不到别的ns中的tid和pid，只需要跑出来的结果，和不启用这个功能的pid明显不同即可（我跑了挺多次，这个koid，每次都一样的）。

7/UTS Namespace

    当上面的框架都已经差不多了，这个UTS命名空间还有什么难度啊，UTS主要是记录了内核版本啦，主机名称啦这种东西，框架就上面那个框架，实现我都不想写。难道还有吉祥物认为这种东西很难么？不会吧不会吧。

    （9.1）打算从这个开始做最初的突破口。uts ns包括可以修改的部分，hostname，和domainname两个部分，以及不可以修改的部分——这部分，反正不管怎样，当机器确定之后，这部分都是写死的。

    linux对应的系统调用有那么几个，首先是clone的时候，会调用copy_utsname()

    其次，在copy之后，可以使用sethostname，setdomainname，更改这两个可以修改的信息

    通过gethostname和getdomainname函数获取这两个信息

    以及通过uname获取当前uts ns中的所有信息，包括可以修改以及不可以修改的部分。

    （对于这样一个没啥卵用的结构体，这描述我觉得已经完善了，就这样）

    （实现的时候，补充一句，这个真的绝了！他连系统调用号都对不上，__NR_sethostname我找到了，那set总得有get吧，我看的Linux版本里面有__NR_gethostname，这个愣是没有！！！绝了！！！我总不可能去文件里面把系统调用号给改一圈吧？然后去群里问大佬，大佬说直接加上就完了，规范什么，不要紧，啊这哈哈哈哈哈，我干完这一票再干这项目我就是伞兵。
    
    所以函数我写那里去，但是直接用uname就完了。这个系统调用号我就不加了。
    
    关于uname，原先有一个现成的实现，但是没有考虑uts ns，所以需要在那个上面改。
    
    改的地方就是sys_uname函数全都替换掉）

    测试：
    
    目前我还是没搞明白这个怎么弄C函数去调用，但是在other-test集里面，有个uname的程序，可以测试一下
    
    （不知道为什么无论按照原有的代码，还是我自己的实现，都没办法去完整的呈现uname需要的信息，最多只有一个开头的“linux”，不过，这并不是我的namespace的问题，他原来的代码也这样，天知道。）
    
    按理说，应该创建一个新的，并且完整的测试一遍，但是，鉴于uts ns太过于简单，就是个字符串儿，只要替换掉之后的uname函数能和之前一样跑，并且确确实实是用的是uts namespace里面的信息，那就没这个必要了。

8/CGroup和rlimit

    在zcore，已经整合进去了一部分rlimit的东西——但是貌似syscall::setrlimit和getrlimit并没有实现进去，我也不知道发生了什么。

    rlimit是用于限制一个进程的资源使用，而cgroup则是用于限制某个进程组，就是一组进程的资源使用限制的。

    然而我实际看了网上的一些对比，发现差别还是蛮大的，比如对cpu限制吧，基于rlimit的ulimit只有对cpu使用时长进行限制，而cgroup还真的限制了CPU使用率。我对于这部分改写的观点是，这部分还是基于已经有的rlimit去做做看吧。

9/IPC

    （还得看代码，没啥头绪）

10/user ns和Linux下的ns_capable函数

    在Linux下，这个函数就是用来检查是否有权限进行执行的，这和ns有非常大的关系，并且，需要递归的去往他的父亲节点去寻找。具体Linux下的实现我不多说了。

    （9.1）害，我还是记录一下好了。首先docker本身默认是不设置新的user namespace的，所以如果从轻量化的角度其实写个空的结构让他去弄没关系的，不会影响docker的使用。但是考虑到usr ns本身在这个ns体系中的地位。这又是不得不实现的部分。

    除了usr之外的ns，都会指向

    user ns包括uid和gid，也就是用户id和group id，以及capability两个部分。

    capability的字段在内核中include/uapi/linux/capability.h里面有枚举宏。

    这里面主要是用于权限控制的。也就是用于 Linux User/Group/Other 用户权限管理机制的。在创建新的usr ns，本身不需要任何的权限，但是创建其他的ns，需要检验相关权限，也即是ns_capable函数。

    关于文件问题。linux本身有万物皆文件的思想，但是zcore不是。上面说的UGO权限系统，本身需要考虑文件的情况。好在rcore-fs里面有考虑进uid和gid。

    但是，考虑到我目前所使用的框架的方案，在每个进程中使用KoID唯一的指向目标的数据结构。如果不加以限制，那么一个ns下的所有进程都可以通过一些系统调用方法访问ns数据结构，并加以更改，这样对于该ns下的其他进程是灾难性的。因此，我在这里加以规定，创建新的ns的系统调用，每个进程都可以弄，但除此之外，需要涉及到ns的一些改变，举个例子比如说chroot，会更改mntns中的rootfs，就需要创建该ns的根进程才有权限去做。（不然如果大家都可以改rootfs，那子进程还好说，父进程岂不是要完蛋），因此，我这里用这个函数，主要是检测是否是相关功能下，对应ns的根进程。

11/如何调用系统调用进行测试的记录

    （害，总是嫌弃别人写的代码攻略非常简单，看不明白，结果自己写的也差不多，无论如何非常感谢对这个问题做出解答的大佬们，羞愧ing）

    首先是根文件夹下面的./rootfs，把交叉编译好的运行文件放里面就好了。不用敲什么命令。

    其次是，需要装个交叉编译器，这个坑我是不想踩第二遍了，也不希望有人踩第二遍。简单来说，他官方的那个需要装一大堆子模块，本来网速就不好，笼笼统统需要好几个g，能下载完就有鬼了，如果有科学上网，强烈推荐挂上。
    
    (这里把原来的攻略删了，因为发现自己还是掉坑里了。原来的是弄那个linux gcc版本的，但是zcore这个，他要的是musl的环境)

    没啥说的，去把那个交叉编译器给下载下来吧。

    cd进相应目录。

    对于子模块，显然我要装的是musl那个版本，所以newlib可以不要，我是在qemu里面用的，这个早就配置好了，而pk，spike则是模拟环境，和qemu类似，也可以不要。所以git rm 对应的子模块。（请弄清楚到底哪几个不要哦）

    随后，去.gitmodule里面查看对应的软件包和版本号，然后，如果有gitee里面直接可以用的，在当前目录下面，直接git clone，包括版本号。。

    随后configure之后（需要--prefix指定输出目录），make musl。

    装完配环境变量去。

    然后敲c代码吧。整个仓库找不到一个标准的C hello world程序，我也是醉了。

12/TODO

    测试样例的问题，这真是让人无奈。/proc没了，依赖于每个proc的ns又该怎么办？(反正这个项目我也只能把功能尽量做全了，实现肯定只能因地制宜了)

    （2022.08.24）开会的时候听取了一下杨德瑞大佬的建议，反正还是得自己尝试哪些能用呗。再说吧

    union fs的问题（反正rcore-fs那部分我是不打算改了）。这个主要是用于docker的文件和镜像多层堆叠的，但是我只是内核部分实现一下。这我表示不做，但是如果要实现一个docker，那么这是必须的。

    cgroup里面会控制某一组资源的使用，但是当多核情况下，这个资源限制怎么弄，我非常的迷惑。目前还在看linux的内核。

    （2022.08.24）开会的时候商量了一下，很多地方写的稀烂的代码，我实在不想搞。主要是多核的通信，这还得特意去设计一个算法，太难为我了。

    mount namespace中shared subtree，这里我给个知乎链接：https://zhuanlan.zhihu.com/p/166393945 由于存在shared属性和同样的传播属性问题，算了我也讲不清楚，总之，实现我不实现了，但数据结构会尽量设计进去。

    （2022.09.1）usr ns涉及到UGO权限系统，好在rcore-fs也有相关数据结构，试着去解决这个问题。